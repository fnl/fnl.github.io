<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
				<meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>fnl.es &middot; articles tagged "text mining"</title>
        <link rel="shortcut icon" href="http://fnl.es/favicon.ico" />
<link href="http://fnl.es/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="fnl.es Atom Feed" />
        <link href="http://fnl.es/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="fnl.es RSS Feed" />

        <link rel="stylesheet" href="http://fnl.es/theme/css/screen.css" type="text/css" />
        <link rel="stylesheet" href="http://fnl.es/theme/css/pygments.css" type="text/css" />
        <!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=3728421; 
var sc_invisible=1; 
var sc_security="a5624e69"; 
</script>
<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script>
        <!-- End of StatCounter Code for Default Guide -->
    </head>
    <body>
        <!-- Start of StatCounter Code for Default Guide -->
<noscript><div class="statcounter"><a title="hit counter"
href="http://statcounter.com/free-hit-counter/"
target="_blank"><img class="statcounter"
src="http://c.statcounter.com/3728421/0/a5624e69/1/"
alt="hit counter"></a></div></noscript>
        <!-- End of StatCounter Code for Default Guide -->
<div id="header">
            <ul id="nav">
                <li class="ephemeral selected"><a href="http://fnl.es/tag/text-mining.html">text mining</a></li>
                <li><a class="flagred" href="http://fnl.es">Home</a></li>
<li><a class="flagyellow" href="http://fnl.es/pages/about.html">About</a></li>
<li><a class="flagyellow" href="http://fnl.es/pages/projects.html">Projects</a></li>
<li><a class="flagred" href="http://fnl.es/archives.html">Archives</a></li>
            </ul>
            <div class="header_box">
                <h1><a href="http://fnl.es">fnl.es</a></h1>
                <h2><a href = "mailto:flo@fnl.es" id="webmaster">fnl</a> en España</h2>            </div>
        </div>
        <div id="wrapper">
            <div id="content">
                <h4 class="date">Jan 2015</h4>

								<div class="mobile-hide">
									<!--a class="twitter-timeline" width="180px" data-dnt="true" data-chrome="noheader nofooter transparent" href="https://twitter.com/flowing" data-widget-id="393739277646852096"></a>
									<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script-->
								</div>
                <div class="post">
<h2 class="title">
                        <a href="http://fnl.es/segtok-a-segmentation-and-tokenization-library.html" rel="bookmark" title="Permanent Link to &quot;segtok - a segmentation and tokenization library&quot;">segtok - a segmentation and tokenization library</a>
                    </h2>

                    <p><strong>tl;dr</strong>
Surprisingly, it is hard to find a good command-line tool for sentence segmentation and word tokenization that works well with European languages.
Here, I present <a class="reference external" href="https://pypi.python.org/pypi/segtok">segtok</a>, a <strong>Python3</strong> package, API, and Unix command-line tool to remedy this shortcoming.</p>
<div class="section" id="text-processing-pipelines">
<h2>Text processing pipelines</h2>
<p>This is the second in a series of posts that will present lean and elegant text processing tools to take you across the void from your document collection to the linguistic processing tools (<em>and back</em>, but more on that in the future).
In the <a class="reference external" href="http://fnl.es/a-review-of-sparse-sequence-taggers.html">last post</a>, I discussed sequence taggers, as they form the entry point to natural language processing (NLP).
Today I am presenting existing tools and a little library of mine for pre-processing of Germanic and Romance language text (essentially, because I am not knowledgeable of any others...).
Text processing pipelines roughly consist of the following three steps:</p>
<ol class="arabic simple">
<li>Document extraction</li>
<li>Text pre-processing</li>
<li>Language processing</li>
</ol>
<p>There are many good tools around for document extraction, in particular Apache <a class="reference external" href="http://tika.apache.org/">Tika</a> is a great software library I highly recommend for this task.
(As a matter of fact, if you want to improve your programming skills and see some real-life, clean implementations of nearly all Java/GoF software patterns, have a look at the innards of Tika.)
If you want to extract data from PDFs in particular, you should be looking for your preferred tool in the huge collection of software that is based on the excellent <a class="reference external" href="http://www.foolabs.com/xpdf/">xpdf</a> library or even OCR libraries like <a class="reference external" href="https://code.google.com/p/tesseract-ocr/">Tesseract</a>.
As for language processing, there are several tools for chunking and tagging with dynamic graphical models that you can choose from, as outlined in an <a class="reference external" href="http://fnl.es/a-review-of-sparse-sequence-taggers.html">earlier post</a> of mine, and for uncovering more involved semantic relationships, dependency parsers like <a class="reference external" href="https://github.com/syllog1sm/redshift">RedShift</a> are available.</p>
</div>
<div class="section" id="overview-and-motivation">
<h2>Overview and motivation</h2>
<p>However, for the intermediate pre-processing, short from cooking up your own solution, the currently best solution is to use one of the large natural language processing (NLP) frameworks.
There are a few sentence segmentation and tokenization libraries around, particularly in Perl, but they do not have the desired properties to handle more complex cases or are long <a class="reference external" href="http://mailman.uib.no/public/corpora/2007-October/005429.html">forgotten</a>.
The only more recent, statistics-based tool I could find is <a class="reference external" href="https://code.google.com/p/splitta/">splitta</a>, but development seems to have died off yet again.
If you check out its Issues page, nobody seems to be fixing the problems, it does not work with Python 3, and its command-line implementation is not really ready for text processing with Unix.
Another example is <a class="reference external" href="https://www.tm-town.com/natural-language-processing">Pragmatic Segmenter</a>, a rule-based segmenter written in Ruby.
But if you feed it examples with abbreviations or other occurrences of problematic issues I will discuss in this post, you will see that it performs worse than even the statistical approaches provided by the frameworks discussed next.</p>
<p>This leaves you with <a class="reference external" href="http://www.nltk.org">NLTK</a>'s <a class="reference external" href="http://www.nltk.org/_modules/nltk/tokenize/punkt.html">PunktTokenizer</a>, <a class="reference external" href="http://alias-i.com/lingpipe/">LingPipe</a>'s <a class="reference external" href="http://alias-i.com/lingpipe/demos/tutorial/sentences/read-me.html">SentenceModel</a>, <a class="reference external" href="http://opennlp.apache.org/">OpenNLP</a>'s <a class="reference external" href="http://opennlp.sourceforge.net/api/opennlp/tools/sentdetect/SentenceDetectorME.html">SentenceDetectorME</a>, and quite a few more frameworks that have APIs to bridge that gap.
(Again, if you enjoy looking at Java [Kingdom of Nouns...] source code, check out LingPipe - while commercial, it is really well designed.)
However, such a heavy-handed approach is to break a butterfly with a wheel, and in my personal opinion/experience, none of them are doing a particularly good job at segmenting, either.
If you don't believe me (never do!), just compare their performance/results against the rule-based library I am about to present here - you will see that these statistical segmenters produce a significant number of false positives on  orthographically (mostly) correct texts.
Their strength compared to this library here, however, is language independence: the library discussed here (so far?) only works with Indo-European languages, while the mentioned segmenters from the above frameworks can be trained on nearly any language and domain.
Particularly, the unsupervised PunktTokenizer only needs sufficient text and the presence of a terminal marker to learn the segmentation rules on its own.
Similarly, if you want to parse noisy text with bad spelling (Twitter and other &quot;social&quot; media sources), you might be best advised to use those frameworks.
So while I do think these libraries are all great as a whole - and I would recommend any one of them - it is mildly annoying that you have to learn a framework if all you want to do is common text pre-processing.</p>
<p>If you are analyzing corporate documents, patents, news articles, scientific texts, technical manuals, web pages, etc., that tend to have good orthography these statistical tools are not quite up to it and introduce far too many splits, at least for my taste.
This then affects your downstream language processing, because the errors made by the pre-processing will be propagated and, in the worst case, even amplified.
Therefore, text processing pipelines commonly end up doing both (2) and (3) using one such framework, but years of experience have shown me that you soon will be wanting to explore methods beyond whatever particular framework you chose offers.
That then can mean that you have to re-conceptualize all of (2) to add a different tool or even need to move to a whole new framework.
If the performance of the newly integrated framework then isn't that stellar either, it becomes disputable if it even was worth the effort.
Last but not least, this framework-based software development approach violates one of the most fundamental Unix philosophies:</p>
<blockquote>
“A  program should do one thing and it should do it well.
Programs should handle <em>text streams</em>, because that is a universal interface.”
(Doug McIlroy)</blockquote>
<p>(Yes, I know, it seems this library is violating the “one thing” rule because it does two things: segmenting and tokenization.
But as you will see, the library comes with two independent scripts and APIs for each step.)</p>
<p>The next two sections are for newcomers to this topic and explains why segmenting and tokenizing isn't that trivial as it might appear.
If you are an expert, you can skip the next two sections and read on where <a class="reference external" href="https://pypi.python.org/pypi/segtok">segtok</a> is introduced.</p>
</div>
<div class="section" id="what-is-sentence-segmentation-and-tokenization">
<h2>What is sentence segmentation and tokenization?</h2>
<p>Nearly any text mining and/or linguistic analysis starts with a sentence and word segmentation step. That is, determining all the individual spans in a piece of text that constitute its sentences or words.
Identifying sentences is important because they form logical units of thought and represent the borders of many grammatical effects.
All our communication - statements, questions, and commands - are expressed by sentences or at least a meaningful sentence-like fragment, i.e., a phrase.
Words on the other hand are the atomic units that form the sentences, and ultimately, our language.
While words are built up from a sequence of symbols in most languages, these symbols have no semantics of their own (except for any single-symbol words in that language, naturally).
Therefore, nearly any meaningful text processing task will require the segmentation of the sequence of symbols (characters in computer lingo) into sentences and words.
These words are, at least in the context of computational text processing, often called <strong>tokens</strong>.
Beyond the actual words consisting of letters, a token includes atomic units consisting of other symbols.
For example, the sentence terminals (., !, and ? are three such tokens), a currency symbol, or even chains of symbols (for example, the ellipsis: …).
By following through with this terminology, the process of segmenting text into these atomic units is commonly called <em>tokenization</em> and a computer subroutine doing this segmentation is known as a <em>tokenizer</em>.</p>
</div>
<div class="section" id="sentence-segmentation-and-tokenization-is-hard">
<h2>Sentence segmentation and tokenization is hard</h2>
<p>While this segmentation step might initially sound like a rather trivial problem, it turns out the rabbit hole is deep and no perfect solution has been found to date.
Furthermore, the problem is made harder by the different symbols and their usage in distinct languages.
For example, just finding word boundaries in Chinese is non-trivial, because there is not boundary marker (unlike the whitespace used by Indo-European languages).
And when looking into technical documents, the problem can grow even more out of hand.
Names of chemical compounds, web addresses, mathematical expressions, etc. are all complicating the way one would normally define a set of word boundary detection rules.
Another source of problems are texts from public internet fora, such as Twitter.
Words are not spelled as expected, the spaces might be missing, and emoticons and other ASCII-art can make defining the correct tokenization strategy a rather difficult endeavor.
Similarly, the sentence terminal marker in many Indo-European languages is the full-stop dot – which coincidentally is also used as the abbreviation marker in those languages.
For example, detecting the (right!) three sentences in in the following text fragment is not that trivial, at least for a computer program.</p>
<blockquote>
Hello, Mr. Man. He smiled!! This, i.e. that, is it.</blockquote>
<p>If the text fragments are large or the span contains many dots, even humans will start to make many errors when trying to identify all the sentence boundaries.
Certain proper nouns (gene names, or “amnesty international”, for example) might demand that the sentence begins with a lower case letter instead of the expected upper-case.
A simple typo might have been the cause for a sentence starting with a lower-case letter, too.
Again in public internet fora, users sometimes resort to using only lower- or upper-case for their  messages or write in an orthographically invalid mix of letter casing.</p>
</div>
<div class="section" id="introducing-segtok-a-python-library-for-these-two-issues">
<h2>Introducing segtok – a Python library for these two issues</h2>
<div class="highlight"><pre>pip3 install segtok
</pre></div>
<p>The Unix approach to software (one thing only, with a text-based interface [that can be used with pipes]) allows you to integrate programs at each stage of your tool-chain and makes it simple to quickly exchange any parts.
If you use a large framework, on the other hand, you are constrained by it and might feel tempted to accept that some of the things you will be doing with it aren't done quite as efficiently as possible.
And the more you make use of that large framework, the less attractive it is to switch your tooling and move out of that &quot;comfort zone&quot;.
I think this issue has a direct, detrimental effect on our ability to experiment and adapt to new tools, software, and methods.</p>
<p>Due to the many different ways this problem can be solved and the inherent complexity if considering all languages, <a class="reference external" href="https://pypi.python.org/pypi/segtok">segtok</a>, the library presented here, is confined to processing orthographically regular Germanic (e.g., English) and Romance (e.g., Spanish) texts.
It has a strong focus on those two and German, which all use Latin letters and standard symbols (like .?!”'([{, etc.).
This is mostly based on the fact that I only know those three languages to some reasonable degree (my tourist-Italian does not count...) - while help/contributions to make segtok work in more languages would be very welcome!
Furthermore, <a class="reference external" href="https://pypi.python.org/pypi/segtok">segtok</a> was made to cope with text having the following properties:</p>
<ul class="simple">
<li>Fully capable of handling the full Unicode space.</li>
<li>A sentence termination marker must be present.</li>
<li>Texts that follow a mostly regular writing style - in particular, segtok is not tuned for Twitter's highly particular orthography.</li>
<li>It can handle technical texts (containing, e.g., chemical compounds) and internet URIs (IP addresses, URLs and e-mail addresses).</li>
<li>The tool is able to handle (valid) cases of sentences starting with a lower-case letter and correctly splits sentences enclosed by parenthesis and/or quotation marks.</li>
<li>It is able to handle some of the more common cases of heavy abbreviation use (e.g., academic citations).</li>
<li>It treats all <em>Unicode</em> dashes (there are quite a few of them in Unicode land) “The Right Way” - a functionality surprisingly absent from most tools.</li>
</ul>
<p>Overall, the two scripts that come with segtok have a very simple plain-text, line-based interfaces that work well when joined with Unix pipe streams.
The first script, <tt class="docutils literal">segmenter</tt>, segments sentences in (plain) text files into one sentence per line.
The other, <tt class="docutils literal">tokenizer</tt>, splits tokens on single lines (usually, the sentences from the <tt class="docutils literal">segmenter</tt>) by adding whitespaces where necessary.
On the other hand, if you are a Python developer, you can use the functions (&quot;Look Ma, no nouns!&quot;...) provided by this library to incorporate this approach in your own software (the tool is MIT licensed, btw.).
Segtok is designed to handle texts with characters from the entire Unicode space, not just ASCII or Latin-1 (ISO-8859-1).</p>
</div>
<div class="section" id="sentence-segmentation-with-segtok">
<h2>Sentence segmentation with segtok</h2>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">segtok.segmenter</span> <span class="kn">import</span> <span class="n">split_single</span><span class="p">,</span> <span class="n">split_multi</span>
</pre></div>
<p>On the sentence level, segtok can detect sentences that are contained inside brackets or quotation marks and maintains those brackets as part of the sentence;
For example:</p>
<ul class="simple">
<li>(A sentence in parenthesis!)</li>
<li>Or a sentence with &quot;a quote!&quot;</li>
<li>'How about handling single quotes?'</li>
<li>[Square brackets are fine, too.]</li>
</ul>
<p>The segmenter is constrained to only segment on single lines ( <tt class="docutils literal">split_single</tt> - sentences are not allowed to cross line boundaries) or to consecutive lines ( <tt class="docutils literal">split_multi</tt> - splitting is allowed across newlines inside “paragraphs” separated by two or more newlines).
(If you really want to extract sentences that cross consecutive newline characters, please remove those line-breaks from your text first.
Segtok assumes your content has some minimal semantical meaning, while superfluous newlines are nothing more than noise.)
It gracefully handles enumerations, dots, multiple terminals, ellipsis, and similar issues:</p>
<ul class="simple">
<li>A. The first assumption.</li>
<li>2. And that is two.</li>
<li>(iii) Third things here.</li>
<li>What the heck??!?!</li>
<li>A terminal ellipsis...</li>
</ul>
<p>In essence, a valid sentence terminal must be represented by one of the allowed Unicode markers.
That is, the many Unicode variants of ., ?, and !, and the ideographic full-stop: “。” (a single character).
Therefore, <em>this library cannot guess a sentence boundary if the marker is absent</em>!
After the marker, up to one quotation mark and one bracket may be present.
Finally, the marker must be separated from the following non-space symbol by at least one whitespace character or a newline.</p>
<p>This requires that the sentence boundaries do obey some limited amount of regularity.
But at the same time, the pesky requirement that a marker is followed by upper-case letters is absent from this strategy.
In addition, this means that “inner” abbreviation markers are never a candidate (such as in “U.S.A.”).
On the other hand, any markers that do not follow this “minimal” pattern will always result in false negatives (i.e., not be split).
While missing markers and markers not followed by a space character do occur, those cases are very infrequent in orthographically correct texts.</p>
<p>After these <em>potential</em> markers have been established, the method goes back and looks at the surrounding text to determine if that marker is not at a sentence boundary after all.
This step recuperates cases like initials (“A. Name”), species names (“S. pombe”) and abbreviations inside brackets, which are common with citations (“[A. Name, B. Other. Title of the work. Proc. Natl. Acad. Sci. 2010]”).
Obvious and common abbreviations (in English, Spanish, and German, so far) followed by a marker are dropped, too.
There are several other enhancements to the segmenter (e.g., checking for the presence of lower-case words that are unlikely start a sentence) that can be studied in the source code and unit tests.
In summary, while coming at a computational cost, this second check is what allows segtok to keep the number of false positive splits to an acceptable low if compared to existing methods.</p>
</div>
<div class="section" id="segtok-s-tokenization-strategy">
<h2>Segtok's tokenization strategy</h2>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">segtok.tokenizer</span> <span class="kn">import</span> <span class="n">symbol_tokenizer</span><span class="p">,</span> <span class="n">word_tokenizer</span><span class="p">,</span> <span class="n">web_tokenizer</span>
<span class="kn">from</span> <span class="nn">segtok.tokenizer</span> <span class="kn">import</span> <span class="n">split_possessive_markers</span><span class="p">,</span> <span class="n">split_contractions</span>
</pre></div>
<p>The tokenization approach uses a similar approach.
First, a maximal token split is made, and then several functions wrap this basic approach, encapsulating successively more complex rules that join neighboring tokens back together based on their orthographic properties.
The basic, maximum split rule is to segment everything that is separated by spaces and then within the remaining non-space spans, split anything that is alphanumeric from any other symbols:</p>
<p>a123, an alpha-/-beta stabilizer... → _a123_  _,_  _an_  _alpha_  _-/-_  _beta_  _stabilizer_  _..._</p>
<p>This functionality is provided by the <tt class="docutils literal">symbol_tokenizer</tt> .
Next, the non-alphanumeric <em>symbols</em> are further analyzed to determine if they should form part of a neighboring alphanumeric <em>word</em>.
If so, the symbols are merged back together with their alphanumeric spans.</p>
<ul class="simple">
<li>Abbreviation markers are attached back on to the proceeding word (“Mr.”).</li>
<li>Words with internal dots, dashes, apostrophes, and commas are joined together again (“192.168.1.0”, “Abel-Ryan's”, “a,b-symmetry”).</li>
<li>The spaces inside a word-hyphen-spaces-word sequences are dropped.</li>
<li>Superscript digits are attached to the proceeding word if it is likely to be a Physical unit (“m³”)</li>
</ul>
<p>This set of functionality is provided by the <tt class="docutils literal">word_tokenizer</tt>.
Finally, if desired, a Web-mode function will further ensure that valid e-mail addresses and URLs (including fragments and parameters, but without actual space characters) are always maintained as single tokens (<tt class="docutils literal">web_tokenizer</tt>).
All this ensures that while a decent amount of splitting is made, the common over-splitting of tokens is avoided.
Particularly, when processing biomedical documents, Web content, or patents, too much tokenization might have quite a significant negative impact on any subsequent, more advanced processing techniques.
As before for the segmenter, I believe this is the particular strength of this library.</p>
<p>After the tokenization step, the API provides two functions to optionally go an split off English possessive markers (“Fred's”, “Argus'”) and even contractions (“isn't” → “is n't” [note the attachment of the letter n], “he'll” → “he 'll”, “I've” → “I 've”, etc.), which can be useful for any downstream linguistic parsing (<tt class="docutils literal">split_possessive_markers</tt> and <tt class="docutils literal">split_contractions</tt>).
To use them, just wrap your tokenizer with the preferred method:</p>
<div class="highlight"><pre><span class="n">tokens</span> <span class="o">=</span> <span class="n">split_contractions</span><span class="p">(</span><span class="n">word_tokenizer</span><span class="p">(</span><span class="n">split_multi</span><span class="p">(</span><span class="n">my_text</span><span class="p">)))</span>
</pre></div>
</div>
<div class="section" id="feedback-and-conclusions">
<h2>Feedback and Conclusions</h2>
<p>All this functionality and the API itself are briefly documented on <a class="reference external" href="https://pypi.python.org/pypi/segtok">segtok</a>'s &quot;homepage&quot;.
As there is not very much functionality around, I hope that between this guide and the overview there the library should be fairly easy to use.
Furthermore, in command-line mode, using the <tt class="docutils literal"><span class="pre">--help</span></tt> option will explain you all functionality provided by the two scripts this package installs.</p>
<p>If you would be looking for new features, you are welcome to extend the library or request a new feature on the tool's GitHub <a class="reference external" href="https://github.com/fnl/segtok/issues">Issues</a> page.
In addition, if you use this library and run into any problems, I would be glad to receive bug reports there, too.</p>
<p>Overall, I have attempted to keep the strategy used by segtok as slim as possible.
So if you are using any heavy language processing or sequence analysis tools after segtok, it should have no impact on your throughput at all.</p>
<p>I have compared this library with several other approaches in the wild, and for regular texts, my experience is that it works substantially superior in both segmentation capabilities and runtime performance to all alternatives I have looked into, at least.
As I do not wish to bash any existing tool, I will only name one sentence segmentation approach I like very much: Punkt Tokenizer by Kiss and Strunk, 2006.
PT is a unsupervised, statistical approach to segmentation that “learns” whether to split sentences at sentence terminal markers.
While quite impressive and very versatile due to its unsupervised nature, I can state clearly that segtok's segmenter works substantially better on modern Germanic and Romance texts that (mostly) follow a proper orthography.
Unsurprisingly, segtok's sentence segmenter is substantially faster than a comparable Python <a class="reference external" href="http://www.nltk.org/_modules/nltk/tokenize/punkt.html">implementation</a> of the Punkt Tokenizer by <a class="reference external" href="http://www.nltk.org">NLTK</a>.</p>
</div>


                    <div class="clear"></div>
                    <div class="info">
                        <div class="tags">                            <a href="http://fnl.es/tag/text-mining.html" class="selected">text mining</a>                            <a href="http://fnl.es/tag/nlp.html">nlp</a>                            <a href="http://fnl.es/tag/python.html">Python</a>                        </div>

                    </div>
                    <div class="clear"></div>
                </div>

                <div class="clear"></div>
                <div class="pages">
                    <a href="http://fnl.es/tag/text-mining2.html" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 1 of 4</span>
                </div>

                <div class="clear"></div>
                <div id="footer">
                    <p>
                    <a class="atom" href="http://fnl.es/feeds/all.atom.xml">RSS Feed</a>
                    </p>
                </div>
            </div>
            <div class="clear"></div>
        </div>
    </body>
</html>